## this

- `this` is a keyword that is a pointer to the object on which the member function is called. It is a way for the member function to refer to the object that invoked it.
```c++
void setter(std::string name, int age, std::string address) {
    this->name = name;
    this->age = age;
    this->address = address;
}
```
- In the setter function of the Person class, this is used to refer to the instance of the Person class to which the member function is applied. It is not strictly necessary to use `this->`, and can omit it if there is no naming conflict between the parameters and the member variables.

```c++
void setter(std::string name, int age, std::string address) {
    name = name;
    age = age;
    address = address;
}
```

## r-value l-value error

```c++
void setter(std::string&& name, int&& age, std::string&& address) {
    name = name;
    age = age;
    address = address;
}
```

- this setter takes `r-value` type variables as function parameters, i.e variables that have no identity or in simpler words variables are not declared.

```c++
Person a;
a.setter("henry", 21, "neekendhuku");
```
- the above code works fine, because we are passing `r-value` type variables to `setter()`.
- buttttttttttttttt

```c++
int age = a.get_age();
std::string name = a.get_name();
std::string address = a.get_address();

Person other;
other.setter(name,age,address);
```
- this throws an error

```c++
./getter_setter.cpp: In function ‘int main(int, char**)’:
./getter_setter.cpp:48:18: error: cannot bind rvalue reference of type ‘std::string&&’ {aka ‘std::__cxx11::basic_string<char>&&’} to lvalue of type ‘std::string’ {aka ‘std::__cxx11::basic_string<char>’}
   48 |     other.setter(name,age,address);
      |                  ^~~~
./getter_setter.cpp:11:31: note:   initializing argument 1 of ‘void Person::setter(std::string&&, int&&, std::string&&)’
   11 |     void setter(std::string&& name, int&& age, std::string&& address) {
      |                 ~~~~~~~~~~~~~~^~~~
```

- i know... this.. but i just remembered..

- to solve this... just use `&` and add setter for all member variables or declare variables in main and then pass by reference.

## Constructor, Destructor

### Constructor

- A constructor is a special member function that is automatically called when an object is created. It has the same name as the class and is used to initialize the object's data members or perform any setup necessary for the object to be used

- `Default Constructor` : A constructor with no parameters. It is automatically generated by the compiler if no constructor is explicitly defined. It initializes the members to default values (e.g., zero for numeric types, or empty for strings).

```c++
class Student {
std::string name; // private by default
int age;
public:
    Student() {
        // default constructor
        // default constructor is used when no parameters are passed
        // ex Student s;
        // s will call this when declared
        name = "";
        age = 0;
    }

};
```
- even if `name` and `age` are set to `null` the by default the compiler does that, we can also set name,age to some other values.

- `Parameterized Constructor` :  A constructor with parameters. It allows to initialize the object with specific values at the time of creation.

```c++
class Student {
std::string name; // private by default
int age;
public:
    Student(std::string&& name, int&& age, std::string&& address) {
        this->name = name;
        this->age = age;
        // Student s("henry", 21, "whatever");
        // or use & to just take reference of declared variable.
    } // parameterized constructor
};
```

# Copy Constructor

- `Default Copy Constructor(shallow)` : A shallow copy creates a new object and then copies the contents of the original object into the new object. However, if the original object contains pointers to dynamically allocated memory, the shallow copy only copies the addresses of the memory locations pointed to by those pointers, not the actual data pointed to. As a result, both the original object and the copied object will point to the same memory locations, which can lead to issues if one object modifies the data, affecting the other object.
- `specified (Deep)` : A deep copy, on the other hand, creates a new object and then recursively copies the contents of the original object, including any dynamically allocated memory. This means that the new object has its own copy of all the data, independent of the original object.

- Example

```c++
#include <iostream>
#include <string>

#define endl std::endl

class Student {
std::string name; // private by default
int age;
std::string address;
public:
    // default constructor
    Student() : name("default"), age(0) {}

    Student(const std::string& name, const int& age, const std::string& address) {
        this->name = name;
        this->age = age;
        this->address = address;
    } // parameterized constructor

    void getter() {
        std::cout << this->name << endl;
        std::cout << this->age << endl;
    }

    void setter(const std::string& name, const int& age, const std::string& address) {
        this->name = name;
        this->age = age;
    }
};

int main (int argc, char *argv[]) {
    Student s1("henry", 21, "address");
    s1.getter();
    Student s2 = s1;
    s2.setter("other", 100, "other_address");
    s1.getter();
    return 0;
}
```

- ChatGpt - When you do s2 = s1;, since you haven't provided a custom copy constructor, the default copy constructor provided by the compiler will be used. This default copy constructor performs a shallow copy, meaning it copies the values of each data member from the source object (s1 in this case) to the target object (s2), member by member. For std::string members like name and address, shallow copying will actually create new std::string objects in s2 that are copies of the strings in s1. Therefore, s2 will have its own copies of name and address, and modifying them through s2.setter() will not affect the corresponding variables in s1. However, for non-pointer primitive types like int, shallow copying just copies the value itself, not the memory location. So, changing age through s2.setter() will not affect age in s1 because they are completely independent copies. Therefore, calling s2.setter() will indeed modify the member variables of s2 without affecting s1. Each object (s1 and s2) has its own set of member variables with their own memory locations.

- Copy Constructor

```c++
Student(const Student& copy_from_to_current_obj) {
    this->name = copy_from_to_current_obj.name;
    this->age = copy_from_to_current_obj.age;
    this->address = copy_from_to_current_obj.address;
}
```

# Destructor

- use this..

```c++
~Student() {
    std::cout << "Destructor is called" << endl;
};
```

- or this..

```c++
~Student() {};
```


- `~Student();` throws an error...

```c++
/usr/bin/ld: /tmp/ccJZBjSw.o: in function `main':
constructor_des.cpp:(.text+0x105): undefined reference to `Student::~Student()'
/usr/bin/ld: constructor_des.cpp:(.text+0x1e9): undefined reference to `Student::~Student()'
/usr/bin/ld: constructor_des.cpp:(.text+0x1f8): undefined reference to `Student::~Student()'
/usr/bin/ld: constructor_des.cpp:(.text+0x2c6): undefined reference to `Student::~Student()'
/usr/bin/ld: constructor_des.cpp:(.text+0x2da): undefined reference to `Student::~Student()'
collect2: error: ld returned 1 exit status
```

- ChatGpt : The error message you're seeing, undefined reference to 'Student::~Student()', typically indicates that the linker is unable to find the definition of the destructor for the Student class. In your code, you've declared the destructor for the Student class using ~Student();, but you haven't provided a definition for it. Since the compiler-generated destructor would be sufficient for your purposes, you can simply remove the declaration for the destructor in your class.

