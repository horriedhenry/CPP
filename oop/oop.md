## this

- `this` is a keyword that is a pointer to the object on which the member function is called. It is a way for the member function to refer to the object that invoked it.
```c++
void setter(std::string name, int age, std::string address) {
    this->name = name;
    this->age = age;
    this->address = address;
}
```
- In the setter function of the Person class, this is used to refer to the instance of the Person class to which the member function is applied. It is not strictly necessary to use `this->`, and can omit it if there is no naming conflict between the parameters and the member variables.

```c++
void setter(std::string name, int age, std::string address) {
    name = name;
    age = age;
    address = address;
}
```

## r-value l-value error

```c++
void setter(std::string&& name, int&& age, std::string&& address) {
    name = name;
    age = age;
    address = address;
}
```

- this setter takes `r-value` type variables as function parameters, i.e variables that have no identity or in simpler words variables are not declared.

```c++
Person a;
a.setter("henry", 21, "neekendhuku");
```
- the above code works fine, because we are passing `r-value` type variables to `setter()`.
- buttttttttttttttt

```c++
int age = a.get_age();
std::string name = a.get_name();
std::string address = a.get_address();

Person other;
other.setter(name,age,address);
```
- this throws an error

```c++
./getter_setter.cpp: In function ‘int main(int, char**)’:
./getter_setter.cpp:48:18: error: cannot bind rvalue reference of type ‘std::string&&’ {aka ‘std::__cxx11::basic_string<char>&&’} to lvalue of type ‘std::string’ {aka ‘std::__cxx11::basic_string<char>’}
   48 |     other.setter(name,age,address);
      |                  ^~~~
./getter_setter.cpp:11:31: note:   initializing argument 1 of ‘void Person::setter(std::string&&, int&&, std::string&&)’
   11 |     void setter(std::string&& name, int&& age, std::string&& address) {
      |                 ~~~~~~~~~~~~~~^~~~
```

- i know... this.. but i just remembered..

- to solve this... just use `&` and add setter for all member variables or declare variables in main and then pass by reference.

## Constructor, Destructor

### Constructor

- A constructor is a special member function that is automatically called when an object is created. It has the same name as the class and is used to initialize the object's data members or perform any setup necessary for the object to be used

- `Default Constructor` : A constructor with no parameters. It is automatically generated by the compiler if no constructor is explicitly defined. It initializes the members to default values (e.g., zero for numeric types, or empty for strings).

```c++
class Student {
std::string name; // private by default
int age;
public:
    Student() {
        // default constructor
        // default constructor is used when no parameters are passed
        // ex Student s;
        // s will call this when declared
        name = "";
        age = 0;
    }

};
```
- even if `name` and `age` are set to `null` the by default the compiler does that, we can also set name,age to some other values.

- `Parameterized Constructor` :  A constructor with parameters. It allows to initialize the object with specific values at the time of creation.

```c++
class Student {
std::string name; // private by default
int age;
public:
    Student(std::string&& name, int&& age, std::string&& address) {
        this->name = name;
        this->age = age;
        // Student s("henry", 21, "whatever");
        // or use & to just take reference of declared variable.
    } // parameterized constructor
};
```
