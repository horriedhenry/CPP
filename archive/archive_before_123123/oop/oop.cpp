#include <iostream>
#include <string>
using namespace std;

/*
NOTES : 
Default Copy Constructor(shallow):

The default copy constructor is automatically generated by the compiler when you
don't provide a custom copy constructor in your class. It performs a member-wise
copy of the data members from the source object to the new object. If the class
contains pointer members, only the pointers are copied, resulting in a shallow
copy. This means that both the source object and the copied object will point to
the same memory location, potentially leading to issues if the memory is
deallocated or modified. The default copy constructor is suitable for many
simple classes and can work well when the class doesn't contain any dynamically
allocated memory or external resources.

specified (Deep) :

A specified copy constructor is a copy constructor that you have declared and
defined in your class. By providing a custom implementation, you can define how
the copying of objects should be performed. This allows you to control the
behavior of the copy constructor based on the requirements of your class.

When you specify a copy constructor, it overrides the default copy constructor
provided by the compiler. You can implement a deep copy in the custom copy
constructor, which involves creating new copies of dynamically allocated memory
or other resources to avoid issues with shallow copies.

In summary, a specified copy constructor is one that you explicitly define in
your class, allowing you to customize the copy behavior. It overrides the
default copy constructor and provides control over how objects are copied, which
is particularly useful when dealing with dynamically allocated memory or
external resources.

Operator overloading :

In the given code, the section bool operator==(Student& stud) is an example of
operator overloading. Specifically, it overloads the equality operator (==) for
objects of the Student class.

By overloading the equality operator, you can define custom behavior for
comparing two Student objects. In this case, the overloaded == operator compares
the attributes (name, age, and Gpa) of two Student objects to determine if they
are equal or not.


The function operator== is defined with the return type bool (boolean) since it
checks for equality and returns either true or false. It takes a reference to
another Student object (stud) as a parameter. This allows the operator to
compare the attributes of the current object (referred to by this) with the
attributes of the object passed as an argument (stud). Inside the function, it
compares the attributes of the two objects using the == operator. If all
attributes are equal, it returns true; otherwise, it returns false. By
overloading the == operator in this way, you can use the operator to compare two
Student objects directly, as shown in the main function:
*/
class Student {
private:
    std::string name;
    float Gpa;
    int age;

public:
    // setter method
    void setAll(std::string name, int age, float Gpa) {
        // read comments on getAll() , it's the same here too set one or all
        // you cal also make some attribues of this class public
        this->name = name;
        this->age = age;
        this->Gpa = Gpa;
    }
    // getter method
    void print_DataMember() {
        // You also can just return one member or every attribute using getter
        // you get the idea
        cout<<this->name<<endl;
        cout<<this->age<<endl; 
        cout<<this->Gpa<<endl;
    }
    // Constructors
    Student(std::string name, int age, float Gpa) {
        // It's like a setter but it will be called
        // if the user wannts to set the attribues when the object is created
        // like say Student Tim("Tim", 21, 9.8);, then this constructor will
        // be called otherwise , ex : Student Tim; the Default constructor will
        // be called
        // if you create this kind of constructor you should also definetly
        // create a Default connstructor , otherwise it will throw an error
        this->name = name;
        this->age = age;
        this->Gpa = Gpa;
    }// Parametrised constructor

    // Default constructor
    Student() {
        this->name = "Default";
        this->age = 0;
        this->Gpa = 0;
        cout<<"Default constructor called"<<endl;
    }

    // Copy constructor
    Student(Student &student) {
        // Called automatically
        // If a user wants to copy all the contents form an existing object
        // student is an object from which the data will be copied to a new
        // object that is created
        this->name = student.name;
        this->age = student.age;
        this->Gpa = student.Gpa;
        // This is not Default copy constructor
        // Default copy constructor does a shallow copy
        // But a specified copy constructor does a deep copy
        // Refer NOTES for shallow and deep copy
    }

    //Destructor(will clear the object created by the  class to free up memory)
    //(May be i will check later)
    ~Student() {
        //Destructor is called after the main() returns 0
        cout<<"Destructor is called"<<endl;
    };

    // Operator overloading
    bool operator == (Student& stud) {
        // This function overloads the equality operator and use them for objects 
        // of Student class(only student class)[check example in main()]
        // Check NOTES for ChatGpt response
        // If you do not specify this then you cannot compare two objects.
        // You can also just compare sme data members, rather than all.
        if(this->name == stud.name && this->age == stud.age && this->Gpa == stud.Gpa) {
            // here this-> refers to Tm objects coz iam checking if Tm objects
            // is equal to Tom object in if statement in main() function
            // and stud refers to Tom object
            return true;
        }
        else return false;
    }
};

int main (int argc, char *argv[]) {
    Student Tim("Tim", 21, 9.8);
    Tim.print_DataMember();
    Student Tom("Tom", 24, 10);
    Student Tm = Tom;// copy constructor will be used
    Tm.print_DataMember();

    // Operator overloadin example
    if(Tm == Tom) {
        // checks if all the data members of Tm == Tom
        // you can also check if some data members are equal
        // It depends on what you are checking in operator == () function
        // You can define custom behavior for comparing two objects
        cout<<"Tm == Tom"<<endl;
    }
    else cout<<"Tm != Tom"<<endl;
    cout<<"End of Main , Destructors will be called after this"<<endl;
    return 0;
}
